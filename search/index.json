[{"content":"简介 The Graph 是一个去中心化的协议，用于索引和查询区块链数据。它使得开发者能够构建基于区块链的数据应用（dApps），并能快速、高效地查询和访问链上的信息。 在此处，主要用于监听获取我们部署的合约的事件。\nSubgraphs： Subgraph 是一个数据子图，它定义了如何从区块链中抓取和索引数据。开发者通过编写子图来指定数据源、查询事件、映射规则等。 Subgraph 会自动抓取区块链数据，进行索引并存储在数据库中（通常是 PostgreSQL）。开发者可以通过 GraphQL 查询语言来访问这些数据。 GraphQL： The Graph 使用 GraphQL 作为查询语言，允许开发者以非常高效和灵活的方式从区块链中查询数据。 Subgraph 可以处理特定区块链事件（如交易、合约调用等），将这些事件转化为易于查询的数据。 Graph Node： Graph Node是 The Graph 协议的核心组件，负责从区块链上抓取、索引和存储数据。它运行在后端，接收来自 Subgraph 的请求，并将数据存储在数据库中（通常是 PostgreSQL）和去中心化存储（如 IPFS）。 IPFS（InterPlanetary File System）： IPFS 用来存储 Subgraph 的代码、ABI 文件、schema 文件等静态内容。它确保这些文件在去中心化的存储网络中不易篡改，能够安全地被访问。 在线部署 注册 Browse and Explore Subgraphs (thegraph.com)上创建一个Subgraph\n添加 subgraph 在网页上，添加一个 subgraph 工作空间 在线部署 subgraph 控制台中安装依赖\n1 yarn global add @graphprotocol/graph-cli 初始化目录 1 graph init my-subgraph 按照命令行指引，往下走即可。 认证 1 graph auth _your_token_ 构建项目代码 1 graph codegen \u0026amp;\u0026amp; graph build 部署到 the graph的 studio 中 1 graph deploy my-subgraph 此时，我们在 the graph 的官方网页应该能看到变化，说明 subgraph 已经被部署。\n测试 此时，我们在 the graph 的网页仪表板中，点击 playground 执行查询，即可获取到合约对应的事件。经过区块浏览器的对比，两者获取到的事件哈希一致。\n本地部署 Graph 节点 • 完全本地运行（PostgreSQL + IPFS + Graph Node） • 不依赖官方网络 • 更适合： • 👨‍💻 本地开发调试子图 • 🧪 针对测试链或私链部署索引器 • 🕵️‍♀️ 自定义数据抓取需求\ndocker 部署 docker-compose.yml文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 version: \u0026#39;3\u0026#39; # 指定 Docker Compose 文件使用的版本 services: # PostgreSQL 数据库服务（用于 graph-node 存储数据） postgres: image: postgres:15 # 使用官方 postgres 镜像的第15版 environment: POSTGRES_USER: postgres # 设置数据库用户名 POSTGRES_DB: graph-node # 创建的数据库名 POSTGRES_HOST_AUTH_METHOD: trust # 使用 trust 模式，无需密码 POSTGRES_INITDB_ARGS: \u0026#34;--locale=C --encoding=UTF8\u0026#34; # 初始化参数，设置编码为 UTF-8 ports: - \u0026#39;5432:5432\u0026#39; # 将容器的 5432 端口映射到主机的 5432（Postgres 默认端口） volumes: - pgdata:/var/lib/postgresql/ # 使用名为 pgdata 的卷挂载数据目录，持久化存储 # IPFS 服务（用于存储和获取子图文件） ipfs: image: ipfs/go-ipfs:v0.4.23 # 使用 IPFS 官方镜像，版本 0.4.23 ports: - \u0026#39;5001:5001\u0026#39; # IPFS API 接口端口 - \u0026#39;8080:8080\u0026#39; # IPFS 网关端口 - \u0026#39;4001:4001\u0026#39; # IPFS swarm 通信端口（用于 P2P 通信） volumes: - ipfsdata:/data/ipfs # 使用名为 ipfsdata 的卷挂载 IPFS 数据目录 # graph-node 服务（核心服务） graph-node: image: graphprotocol/graph-node:latest # 使用 graph-node 的最新版镜像 ports: - \u0026#39;8000:8000\u0026#39; # GraphQL 查询接口（用于前端查询） - \u0026#39;8020:8020\u0026#39; # 管理接口（用于部署、管理子图） - \u0026#39;8030:8030\u0026#39; # Prometheus 指标端口（监控用） - \u0026#39;8040:8040\u0026#39; # JSON-RPC 指标端口（监控用） - \u0026#39;8001:8001\u0026#39; # 备用 GraphQL 端口或调试用 depends_on: - postgres # 启动前依赖 postgres - ipfs # 启动前依赖 ipfs environment: postgres_host: postgres # PostgreSQL 容器服务名（Docker Compose 会自动识别） postgres_user: postgres # 登录数据库的用户名 postgres_pass: \u0026#39;\u0026#39; # 数据库密码（为空，因为使用 trust 模式） postgres_db: graph-node # 要连接的数据库名 ipfs: \u0026#39;ipfs:5001\u0026#39; # IPFS 容器地址（Docker Compose 内部通信用） ethereum: \u0026#39;anvil:http://host.docker.internal:8545\u0026#39; # 指定以太坊节点地址，这里用的是 Foundry 的 anvil，host.docker.internal 让容器访问宿主机 volumes: - ./data:/data # 本地的 ./data 挂载到容器的 /data 目录（用于存储 graph-node 相关数据） # 声明持久化存储卷 volumes: pgdata: ipfsdata: 启动 docker compose up -d 停止 docker compose down -v\n启动 anvil 1 anvil -vvvv 使用 docker-compose 启动 graph-node 和 postgre 以及 ipfs docker ps 查看是否启动成功\n部署 ShawnERC20 合约到 anvil 上，复制出来合约地址 1 2 3 4 5 forge script script/ERC20/DeployShawnERC20.sol \\ --rpc-url 127.0.0.1:8545 \\ --private-key $PRIVATE_KEY_1 \\ --broadcast \\ -vvvv 创建子图 创建 subgraph 项目，将端口指向 graph-node的管理端口\n1 graph create erc20-subgraph --node http://localhost:8020 完善 subgraph 项目的内容，包括 subgraph.yaml （定义数据域、IPFS 交互、事件处理程序） 和 mapping.ts（处理事件逻辑，解析事件并保存在 Graph 数据库中） 代码见仓库 https://github.com/Shawn-Shaw-x/hello-foundry/tree/main/erc20-subgraph\n生成代码、编译项目 1 graph codegen \u0026amp;\u0026amp; graph build 部署项目到本地 Graph Node 中 1 2 3 graph deploy erc20-subgraph \\ --node http://localhost:8020 \\ --ipfs http://localhost:5001 测试 浏览器上查看 http://localhost:8000/subgraphs/name/erc20-subgraph\n输入\n1 2 3 4 5 6 7 8 { transfers { id from to value } } 通过编写 GraphQL 查询语言，可以看到本地 Graph给我们返回了正确的合约 transfer 事件。本地部署成功。\n","date":"2026-01-27T11:09:19+08:00","image":"https://Uchiha1024.github.io/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2-the-graph/cover_hu_c52a0a450bd1782e.jpg","permalink":"https://Uchiha1024.github.io/p/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%A6%E4%BD%A0%E5%9C%A8%E7%BA%BF%E7%A6%BB%E7%BA%BF%E9%83%A8%E7%BD%B2-the-graph/","title":"手把手带你在线、离线部署 The Graph"},{"content":"合约事件监听方案 ​\t合约事件监听是区块链开发中的常见需求，主要应用于 Dapp、钱包、交易监控、交易所等场景。本文介绍四种常见的监听方案，并通过 Go 实操给出最小可用代码。\nWebSocket（eth_subscribe） ​\t这是实时推送模式，通过 websocket 连接以太坊 RPC 节点，再调用 eth_subscribe 建立双向流进行数据传输。\n​\t流程：\n建立 websocket 连接\n使用合约地址构建过滤参数\n调用 eth_subscribe 通过 JSON-RPC 接口传参，返回的 channel 会持续推送事件结果\n通过 ABI 中的事件签名匹配获取事件\n说明：该方式适合实时获取事件，但系统故障时可能出现事件丢失。\nThe Graph Graph Node 会从区块链读取合约事件（logs），并解析为结构化数据（entities）。 你可以编写 subgraph 并部署到 Graph Node，按自定义逻辑解析并存储事件。\n特点：\n使用 GraphQL 自定义查询\n底层基于 eth_getLogs 拉取数据\n常用于 Dapp 开发，自动索引与存储，开箱即用\neth_getTransactionReceipt 适用于扫链监听：通过 eth_getTransactionReceipt 获取指定交易 hash 的事件日志。 返回值中的 logs 字段即事件列表。\n流程：\nHTTP 连接以太坊 RPC 节点 eth_getBlockNumber() 获取最新区块或指定区块 遍历区块交易，根据 from / to 过滤出目标交易 hash 调用 eth_getTransactionReceipt，解析 log 数据，可用 ABI 的事件签名与 topic[0] 匹配 eth_getLogs 最常用的事件获取方式。通过 eth_getLogs 指定区块范围与合约地址，直接获取日志。\n流程：\nHTTP 连接以太坊 RPC 节点 构造区块范围 + 合约地址 + 事件签名 调用 eth_getLogs 获取指定事件日志 Go 语言监听合约事件实操 eth_getTransactionReceipt 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 func TestGetTransactionReceipt(t *testing.T) { // 加载 .env 文件 err := godotenv.Load() if err != nil { log.Fatalf(\u0026#34;Error loading .env file\u0026#34;) } // 获取环境变量 rpcURL := os.Getenv(\u0026#34;ETHEREUM_RPC_URL\u0026#34;) apiKey := os.Getenv(\u0026#34;ETHEREUM_API_KEY\u0026#34;) contractAddress := os.Getenv(\u0026#34;CONTRACT_ADDRESS\u0026#34;) eventSignature := os.Getenv(\u0026#34;EVENT_SIGNATURE\u0026#34;) if rpcURL == \u0026#34;\u0026#34; || apiKey == \u0026#34;\u0026#34; || contractAddress == \u0026#34;\u0026#34; { log.Fatal(\u0026#34;❌ Missing required environment variables\u0026#34;) } // 连接以太坊节点（使用你的 RPC） client, err := ethclient.Dial(rpcURL + apiKey) if err != nil { log.Fatalf(\u0026#34;❌ 连接失败: %v\u0026#34;, err) } defer client.Close() // 获取最新区块号 latestBlockNum, err := client.BlockNumber(context.Background()) if err != nil { log.Fatalf(\u0026#34;❌ 获取最新区块号失败: %v\u0026#34;, err) } // 根据区块号获取区块 latestBlock, err := client.BlockByNumber(context.Background(), big.NewInt(int64(latestBlockNum))) if err != nil { log.Fatalf(\u0026#34;❌ 获取最新区块内容失败: %v\u0026#34;, err) } // TODO: 真实场景中请替换为目标交易 hash txHash := latestBlock.Transactions()[10].Hash() // 获取交易回执（包含事件 logs） receipt, err := client.TransactionReceipt(context.Background(), txHash) if err != nil { log.Fatalf(\u0026#34;❌ 获取回执失败: %v\u0026#34;, err) } // 遍历日志 for _, vLog := range receipt.Logs { if vLog.Topics[0].Hex() != eventSignature { continue } fmt.Println(\u0026#34;日志地址:\u0026#34;, vLog.Address.Hex()) fmt.Println(\u0026#34;topics:\u0026#34;) for i, topic := range vLog.Topics { fmt.Printf(\u0026#34; - topic[%d]: %s\\n\u0026#34;, i, topic.Hex()) } fmt.Println(\u0026#34;data:\u0026#34;, hex.EncodeToString(vLog.Data)) } } ​\t测试在这个测试中，我们连接了infura的rpc节点，通过eth_getTransactionReceipt获取了log的日志，并筛选出符合Transfer事件签名的事件。\neth_getLogs 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 func TestGetLogs(t *testing.T) { // 加载 .env 文件 err := godotenv.Load() if err != nil { log.Fatalf(\u0026#34;Error loading .env file\u0026#34;) } // 获取环境变量 rpcURL := os.Getenv(\u0026#34;ETHEREUM_RPC_URL\u0026#34;) apiKey := os.Getenv(\u0026#34;ETHEREUM_API_KEY\u0026#34;) contractAddress := os.Getenv(\u0026#34;CONTRACT_ADDRESS\u0026#34;) eventSignature := os.Getenv(\u0026#34;EVENT_SIGNATURE\u0026#34;) if rpcURL == \u0026#34;\u0026#34; || apiKey == \u0026#34;\u0026#34; || contractAddress == \u0026#34;\u0026#34; { log.Fatal(\u0026#34; ❌ Missing required environment variables\u0026#34;) } // 连接以太坊节点（使用你的 RPC） client, err := ethclient.Dial(rpcURL + apiKey) if err != nil { log.Fatalf(\u0026#34;❌ 连接失败: %v\u0026#34;, err) } defer client.Close() // 构造筛选参数 var addresses []common.Address addresses = append(addresses, common.HexToAddress(contractAddress)) var eventSignatures [][]common.Hash eventSignatures = append(eventSignatures, []common.Hash{common.HexToHash(eventSignature)}) query := ethereum.FilterQuery{ BlockHash: nil, FromBlock: big.NewInt(22341322), ToBlock: big.NewInt(22341324), Addresses: addresses, Topics: eventSignatures, } // 发起调用 logs, err := client.FilterLogs(context.Background(), query) if err != nil { log.Fatalf(\u0026#34;❌ 获取 log失败: %v\u0026#34;, err) } // 遍历日志 for _, vLog := range logs { fmt.Println(\u0026#34;📦 日志地址:\u0026#34;, vLog.Address.Hex()) fmt.Println(\u0026#34;📝 topics:\u0026#34;) for i, topic := range vLog.Topics { fmt.Printf(\u0026#34; - topic[%d]: %s\\n\u0026#34;, i, topic.Hex()) } fmt.Println(\u0026#34;📨 data:\u0026#34;, hex.EncodeToString(vLog.Data)) } } eth_getLogs方法获取日志事件相对来讲更简单。只需传入查询参数：\nfromBlock:起始区块号\ntoBlock:终止区块号\naddress:合约地址（可以单个也可以传一个数组）\ntopics:事件的Topic（可以传二维数组）\n1 2 3 4 5 topics := [][]common.Hash{ {transferSigHash}, // topic[0] = 事件签名 {fromAHash, fromBHash}, // topic[1] = from 是 A 或 B {toCHash}, // topic[2] = to 是 C } ","date":"2026-01-22T16:25:22+08:00","image":"https://Uchiha1024.github.io/p/%E5%90%88%E7%BA%A6%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/001_hu_24f0ea161718a0dc.jpg","permalink":"https://Uchiha1024.github.io/p/%E5%90%88%E7%BA%A6%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC/","title":"合约事件监听"},{"content":"岁序轮转，乙巳蛇年的余温尚未散尽，丙午马年的蹄音已踏风而来。从腊月里渐浓的年味，到正月里团圆的欢腾，时光以最隆重的仪式，唤醒藏在烟火人间的期许与感动。这一年，我们不必追光，只需在平凡的日常里，守着烟火气，拾获属于自己的温柔与力量。\n一、年味，是刻在心底的文化密码 马年的年味，藏在街巷的红灯笼里，藏在案板上的团圆饭中，藏在长辈递来的红包里。不同于往年的匆忙，这一年我们更愿意慢下来，感受传统里的仪式感。\n腊月廿八，全家动手贴春联，红纸黑字间，“马到成功”“骏业宏图”的期许跃然纸上，笔墨香混着浆糊的清润，是独属于新年的气息。除夕夜的餐桌，永远是年味最浓的载体：鱼要留到年初一，寓意“年年有余”；饺子里藏一枚硬币，谁吃到便象征着来年顺遂无忧；还有象征龙马精神的红烧蹄膀，每一口都是家人沉甸甸的祝福。\n守岁时围坐炉边，看春晚的欢声笑语，听窗外此起彼伏的爆竹声，长辈们讲着过去的年俗，晚辈们分享着一年的故事。这一刻，时间仿佛被拉长，所有的疲惫都在团圆的烟火里烟消云散。年味从不是某一种具体的事物，而是家人相聚的温暖，是代代相传的仪式，是刻在血脉里的文化密码。\n二、前行，如骏马般向阳而生 马，自古便是奋进、昂扬的象征。丙午马年，恰如一匹奔腾的骏马，带着冲破桎梏的勇气，指引我们向阳而行。过去的一年，我们或许有过迷茫与挫折，有过遗憾与不甘，但那些经历过的风雨，都成了成长路上最珍贵的养分。\n新的一年，不必执着于“功成名就”，更不必在他人的节奏里焦虑。就像骏马驰骋于旷野，不急于抵达终点，而是享受每一步的坚定与从容。对职场人而言，愿你带着“马到成功”的底气，脚踏实地做好每一件事，在深耕中收获成长；对学子而言，愿你秉持“龙马精神”的韧劲，在书山学海中披荆斩棘，不负韶华；对每一个普通人而言，愿你守住心中的热爱，不慌不忙，在自己的赛道上稳步前行。\n人生没有白走的路，每一步都算数。马年的征途，愿我们既能有“一日看尽长安花”的顺遂，也能有“千磨万击还坚劲”的从容，以骏马之姿，踏平坎坷，奔赴属于自己的山海。\n三、温柔，是烟火人间的底色 褪去新年的喧嚣，日子终究要回归平淡。但马年的温柔，恰藏在这些平淡的日常里。是清晨巷口早点铺飘来的豆浆香气，是午后阳光洒在书页上的暖意，是傍晚家人等候的一盏灯火，是朋友久别重逢的一句问候。\n我们总在追逐远方的风景，却忽略了身边的美好。试着在清晨慢下来，吃一顿热气腾腾的早餐；在周末放下手机，陪家人逛一次菜市场，感受人间烟火的鲜活；在闲暇时约上三五好友，谈天说地，重拾久违的快乐。这些细碎的温柔，如同冬日里的暖阳，照亮我们前行的路。\n马年，愿我们都能做一个温柔的人，懂得珍惜眼前人，学会与生活和解。不纠结于过往，不焦虑于未来，只专注于当下的每一分美好，在烟火人间里，收获稳稳的幸福。\n尾声 蹄声阵阵，新岁启封。丙午马年，是充满希望的一年，也是值得用心经营的一年。愿我们带着团圆的温暖，秉持奋进的勇气，怀揣温柔的善意，在新的一年里，不负时光，不负自己，以骏马奔腾之姿，书写属于自己的精彩华章。\n愿新年，胜旧年，往后余生，皆得所愿。\n","date":"2026-01-20T17:33:48+08:00","image":"https://Uchiha1024.github.io/p/%E4%B8%99%E5%8D%88%E9%A9%AC%E5%B9%B4%E5%9C%A8%E7%83%9F%E7%81%AB%E9%87%8C%E6%8B%BE%E8%8E%B7%E6%B8%A9%E6%9F%94%E4%B8%8E%E5%8A%9B%E9%87%8F/cover_hu_44978b3c42b4f6f1.png","permalink":"https://Uchiha1024.github.io/p/%E4%B8%99%E5%8D%88%E9%A9%AC%E5%B9%B4%E5%9C%A8%E7%83%9F%E7%81%AB%E9%87%8C%E6%8B%BE%E8%8E%B7%E6%B8%A9%E6%9F%94%E4%B8%8E%E5%8A%9B%E9%87%8F/","title":"丙午马年，在烟火里拾获温柔与力量"}]